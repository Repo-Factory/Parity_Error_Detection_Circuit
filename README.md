# Contributors

Conner Sommerfield - ECC Generator/Detector
Ryan Jaber - Data Bus and Documentation

# Files

ECC Generator.cct - Circuit takes in 8 inputs which will be data bits to be sent. It must use 4 XOR gates that are attached to inputs in a specific manner to produce
the correct parity bits. Inputs will be I1-I8, but in reality we will need a 12 bit vector to send over the bus. This means we will have to consider the parity bits as 
placeholders and map the inputs to data bits as follows:
    Skip 1 (parity)
    Skip 2 (parity)
    I1 -> 3
    Skip 4 (parity)
    I2 -> 5
    I3 -> 6
    I4 -> 7
    Skip 8 (parity)
    I5 -> 9
    I6 -> 10
    I7 -> 11
    I8 -> 12
P1 will be connected to inputs where binary representation  has a 1 in the LSB. These will be 1, 3, 5, 7, 9, 11 (I1, I2, I4, I5, I7). 
P2 will be connected to inputs where binary representation has a 1 in the 2nd LSB. These will be 2, 3, 6, 7, 10, 11 (I1, I3, I4, I7, I8). 
P3 will be connected to inputs where binary representation has a 1 in the 3rd LSB. These will be 4, 5, 6, 7, 12 (I2, I3, I4, I8).
P4 will be connected to inputs where binary representation has a 1 in the 4rd LSB. These will be 8, 9, 10, 11, 12 (I5, I6, I7,I8).

ECC Detector.cct - Circuit takes in 12 inputs, 4 are parity bits, 8 are data bits. This will be in the order P1, P2, I1, P3, I2, I3, I4,P4, I5, I6, I7, I8
The detector will now perform the same XOR operation as the ECC generator but now including the parity bits. That means that if there are no changes, every
XOR should have inputs that add to an even number and output 0. If they all output 0, we know the data bits have been preserved (no interference). If one of the 
bits changes, we will have XORs that output 1, and coincidentally (based on design obviously) will output 1s based on the incorrect bit (For example a change in 
bit 7 will cause the bits to output 0111). This means we can pass this to a decoder to change the specified bit.

4x16 Decoder.cct - The decoder will take the series of four parity bits and of course output a 1 at the specified output line (7 in this case) as a decoder would.
naturally do(As a side note I started the decoder at 1 so it's a little funky but the exact details are irrelevant - it works). This is great because if we run a 1
to an XOR, it will toggle the other bit. If we run a 0 to it, it will preserve the bit. This means our decoder will output a 1 at the error bit and a 0 and the other
bits, toggling the error and preserving the rest of the bits. This will correct our error and send the correct data to the display even with a bit sent in error.

Circuit 2 Clean.cct - This circuit integrate all the above parts with hex displays and an extra Parity bit as the MSB. We will refer to this bit as P. This bit is 
generated by XORing every bit of the 12 bit sequence. If this bit is 0 but the Hex display for status displays C, we know we have a double parity error. 
The display will normally display 1100 on error but we will add an extra 1 to display 1110 as E in this case. In all other cases, we should contain as normal in our
above implementation. We'll use a series of OR AND and XOR logic to accomplish all of this.
